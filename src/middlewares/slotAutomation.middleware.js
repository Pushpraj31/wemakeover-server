import mongoose from 'mongoose';
import WorkingDays from '../models/workingDays.model.js';
import DailySlots from '../models/dailySlots.model.js';

// Configuration for slot generation
const SLOT_CONFIG = {
  DEFAULT_SLOT_DURATION: 60, // 60 minutes per slot
  DEFAULT_MAX_BOOKINGS: 5,   // 5 bookings per slot
  AUTO_GENERATE_DAYS_AHEAD: 365, // Generate slots for next 365 days
  BATCH_SIZE: 30 // Generate 30 days at a time to avoid memory issues
};

// Middleware to check if working days are configured
export const checkWorkingDaysConfiguration = async (req, res, next) => {
  try {
    const workingDays = await WorkingDays.find({ isActive: true });
    
    if (workingDays.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Working days not configured. Admin must set up working days first.',
        data: {
          configuredDays: 0,
          requiredDays: 7
        }
      });
    }
    
    const configuredDays = workingDays.length;
    const workingDaysCount = workingDays.filter(day => day.isWorking).length;
    
    console.log('ðŸ“… Working days configuration check:', {
      configuredDays,
      workingDaysCount,
      days: workingDays.map(day => ({
        day: day.dayName,
        isWorking: day.isWorking,
        hours: day.isWorking ? `${day.startTime}-${day.endTime}` : 'Closed'
      }))
    });
    
    req.workingDaysConfig = {
      configuredDays,
      workingDaysCount,
      workingDays
    };
    
    next();
  } catch (error) {
    console.error('Error checking working days configuration:', error);
    res.status(500).json({
      success: false,
      message: 'Error checking working days configuration',
      error: error.message
    });
  }
};

// Middleware to auto-generate slots if needed
export const autoGenerateSlotsIfNeeded = async (req, res, next) => {
  try {
    const { date } = req.params;
    const targetDate = new Date(date);
    
    console.log('ðŸ¤– Auto-generating slots for date:', {
      date: targetDate.toISOString().split('T')[0],
      dayOfWeek: targetDate.getDay(),
      dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][targetDate.getDay()]
    });
    
    // Check if slots already exist for this date
    const existingSlots = await DailySlots.findByDate(targetDate);
    
    if (existingSlots) {
      console.log('âœ… Slots already exist for date:', targetDate.toISOString().split('T')[0]);
      req.autoGeneratedSlots = existingSlots;
      return next();
    }
    
    // Get working day configuration for this day of week
    const dayOfWeek = targetDate.getDay();
    const workingDay = await WorkingDays.findOne({ dayOfWeek, isActive: true });
    
    if (!workingDay || !workingDay.isWorking) {
      console.log('âŒ No working day configuration or day is not working:', {
        dayOfWeek,
        dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
        isWorking: workingDay?.isWorking || false
      });
      
      return res.status(404).json({
        success: false,
        message: 'No slots available for this date - not a working day',
        data: {
          date: targetDate.toISOString().split('T')[0],
          dayOfWeek,
          dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
          isWorkingDay: false
        }
      });
    }
    
    // Generate slots based on working day configuration
    const slots = generateSlotsFromWorkingDay(workingDay);
    
    console.log('ðŸ¤– Generated slots for date:', {
      date: targetDate.toISOString().split('T')[0],
      workingDay: `${workingDay.startTime}-${workingDay.endTime}`,
      breakTime: workingDay.breakStart && workingDay.breakEnd ? `${workingDay.breakStart}-${workingDay.breakEnd}` : 'No break',
      generatedSlots: slots.length,
      slots: slots.map(slot => `${slot.startTime}-${slot.endTime}`)
    });
    
    // Create daily slots document
    // For system-generated slots, we need a valid ObjectId
    // Find the first admin user or use a default system ID
    let systemUserId;
    try {
      const adminUser = await mongoose.model('User').findOne({ role: 'admin' });
      systemUserId = adminUser ? adminUser._id : new mongoose.Types.ObjectId();
    } catch (error) {
      // If User model not available, create a valid ObjectId
      systemUserId = new mongoose.Types.ObjectId();
    }
    
    const dailySlots = new DailySlots({
      date: targetDate,
      slots: slots,
      createdBy: systemUserId, // Use valid ObjectId
      notes: `Auto-generated slots based on working day configuration for ${workingDay.dayName}`
    });
    
    await dailySlots.save();
    
    console.log('âœ… Auto-generated slots saved:', {
      date: targetDate.toISOString().split('T')[0],
      slotsCount: dailySlots.slots.length,
      dailySlotsId: dailySlots._id
    });
    
    req.autoGeneratedSlots = dailySlots;
    next();
  } catch (error) {
    console.error('Error auto-generating slots:', error);
    res.status(500).json({
      success: false,
      message: 'Error auto-generating slots',
      error: error.message
    });
  }
};

// Function to generate slots from working day configuration
function generateSlotsFromWorkingDay(workingDay) {
  const slots = [];
  const slotDuration = SLOT_CONFIG.DEFAULT_SLOT_DURATION;
  const maxBookings = SLOT_CONFIG.DEFAULT_MAX_BOOKINGS;
  
  // Convert times to minutes for easier calculation
  const startMinutes = workingDay.startTime.split(':').reduce((acc, time) => (60 * acc) + +time);
  const endMinutes = workingDay.endTime.split(':').reduce((acc, time) => (60 * acc) + +time);
  
  let breakStartMinutes = null;
  let breakEndMinutes = null;
  
  if (workingDay.breakStart && workingDay.breakEnd) {
    breakStartMinutes = workingDay.breakStart.split(':').reduce((acc, time) => (60 * acc) + +time);
    breakEndMinutes = workingDay.breakEnd.split(':').reduce((acc, time) => (60 * acc) + +time);
  }
  
  // Generate slots
  let currentMinutes = startMinutes;
  
  while (currentMinutes + slotDuration <= endMinutes) {
    const slotEndMinutes = currentMinutes + slotDuration;
    
    // Skip break time
    if (breakStartMinutes && breakEndMinutes) {
      // If slot overlaps with break time, skip to after break
      if (currentMinutes < breakEndMinutes && slotEndMinutes > breakStartMinutes) {
        currentMinutes = breakEndMinutes;
        continue;
      }
    }
    
    // Convert minutes back to time format
    const startTime = Math.floor(currentMinutes / 60).toString().padStart(2, '0') + 
                     ':' + (currentMinutes % 60).toString().padStart(2, '0');
    const endTime = Math.floor(slotEndMinutes / 60).toString().padStart(2, '0') + 
                   ':' + (slotEndMinutes % 60).toString().padStart(2, '0');
    
    slots.push({
      startTime,
      endTime,
      maxBookings,
      currentBookings: 0,
      isAvailable: true,
      notes: `Auto-generated slot for ${workingDay.dayName}`
    });
    
    currentMinutes += slotDuration;
  }
  
  return slots;
}

// Middleware to bulk generate slots for date range
export const bulkGenerateSlotsForRange = async (req, res, next) => {
  try {
    const { startDate, endDate } = req.query;
    const start = new Date(startDate);
    const end = new Date(endDate);
    const createdBy = req.user.id;
    
    console.log('ðŸ¤– Bulk generating slots for range:', {
      startDate: start.toISOString().split('T')[0],
      endDate: end.toISOString().split('T')[0],
      createdBy
    });
    
    const generatedSlots = [];
    const skippedDates = [];
    const currentDate = new Date(start);
    
    while (currentDate <= end) {
      const dateStr = currentDate.toISOString().split('T')[0];
      const dayOfWeek = currentDate.getDay();
      
      // Check if slots already exist
      const existingSlots = await DailySlots.findByDate(currentDate);
      if (existingSlots) {
        skippedDates.push({
          date: dateStr,
          reason: 'Slots already exist',
          existingSlotsCount: existingSlots.slots.length
        });
        currentDate.setDate(currentDate.getDate() + 1);
        continue;
      }
      
      // Get working day configuration
      const workingDay = await WorkingDays.findOne({ dayOfWeek, isActive: true });
      
      if (!workingDay || !workingDay.isWorking) {
        skippedDates.push({
          date: dateStr,
          dayOfWeek,
          dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
          reason: 'Not a working day'
        });
        currentDate.setDate(currentDate.getDate() + 1);
        continue;
      }
      
      // Generate slots
      const slots = generateSlotsFromWorkingDay(workingDay);
      
      const dailySlots = new DailySlots({
        date: new Date(currentDate),
        slots: slots,
        createdBy,
        notes: `Bulk generated slots based on ${workingDay.dayName} configuration`
      });
      
      await dailySlots.save();
      
      generatedSlots.push({
        date: dateStr,
        dayOfWeek,
        dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
        slotsCount: slots.length,
        workingHours: `${workingDay.startTime}-${workingDay.endTime}`,
        dailySlotsId: dailySlots._id
      });
      
      currentDate.setDate(currentDate.getDate() + 1);
    }
    
    console.log('âœ… Bulk slot generation completed:', {
      totalDates: Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1,
      generatedSlots: generatedSlots.length,
      skippedDates: skippedDates.length
    });
    
    req.bulkGenerationResult = {
      generatedSlots,
      skippedDates,
      summary: {
        totalDatesProcessed: generatedSlots.length + skippedDates.length,
        slotsGenerated: generatedSlots.length,
        datesSkipped: skippedDates.length,
        totalSlotsCreated: generatedSlots.reduce((sum, item) => sum + item.slotsCount, 0)
      }
    };
    
    next();
  } catch (error) {
    console.error('Error in bulk slot generation:', error);
    res.status(500).json({
      success: false,
      message: 'Error generating slots for date range',
      error: error.message
    });
  }
};

// Middleware to validate date is not in the past
export const validateDateNotInPast = (req, res, next) => {
  const { date } = req.params;
  const targetDate = new Date(date);
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  if (targetDate < today) {
    return res.status(400).json({
      success: false,
      message: 'Cannot generate slots for past dates',
      data: {
        requestedDate: targetDate.toISOString().split('T')[0],
        today: today.toISOString().split('T')[0]
      }
    });
  }
  
  next();
};

// Middleware to validate date is within reasonable range
export const validateDateWithinRange = (req, res, next) => {
  const { date } = req.params;
  const targetDate = new Date(date);
  const today = new Date();
  const maxFutureDate = new Date();
  maxFutureDate.setFullYear(today.getFullYear() + 2); // 2 years ahead
  
  if (targetDate > maxFutureDate) {
    return res.status(400).json({
      success: false,
      message: 'Cannot generate slots more than 2 years in the future',
      data: {
        requestedDate: targetDate.toISOString().split('T')[0],
        maxAllowedDate: maxFutureDate.toISOString().split('T')[0]
      }
    });
  }
  
  next();
};

// Function to get working days summary
export const getWorkingDaysSummary = async () => {
  try {
    const workingDays = await WorkingDays.find({ isActive: true }).sort({ dayOfWeek: 1 });
    
    const summary = workingDays.map(day => ({
      dayOfWeek: day.dayOfWeek,
      dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][day.dayOfWeek],
      isWorking: day.isWorking,
      workingHours: day.isWorking ? `${day.startTime}-${day.endTime}` : 'Closed',
      breakTime: day.isWorking && day.breakStart && day.breakEnd ? `${day.breakStart}-${day.breakEnd}` : 'No break',
      availableSlots: day.isWorking ? generateSlotsFromWorkingDay(day).length : 0
    }));
    
    return {
      configuredDays: workingDays.length,
      workingDays: summary.filter(day => day.isWorking).length,
      totalAvailableSlots: summary.reduce((sum, day) => sum + day.availableSlots, 0),
      summary
    };
  } catch (error) {
    console.error('Error getting working days summary:', error);
    throw error;
  }
};


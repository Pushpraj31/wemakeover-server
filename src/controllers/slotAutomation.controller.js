import WorkingDays from '../models/workingDays.model.js';
import DailySlots from '../models/dailySlots.model.js';
import { 
  bulkGenerateSlotsForRange,
  getWorkingDaysSummary 
} from '../middlewares/slotAutomation.middleware.js';

// Admin: Get working days configuration and slot generation summary
export const getSlotGenerationSummary = async (req, res) => {
  try {
    const userId = req.user.id;
    
    console.log('ğŸ‘‘ Admin - Getting slot generation summary:', { userId });
    
    const workingDaysSummary = await getWorkingDaysSummary();
    
    // Get statistics about existing slots
    const totalSlotsGenerated = await DailySlots.aggregate([
      { $match: { isActive: true } },
      { $project: { slotCount: { $size: '$slots' } } },
      { $group: { _id: null, total: { $sum: '$slotCount' } } }
    ]);
    
    const datesWithSlots = await DailySlots.countDocuments({ isActive: true });
    const upcomingSlots = await DailySlots.find({
      date: { $gte: new Date() },
      isActive: true
    }).sort({ date: 1 }).limit(7);
    
    console.log('âœ… Admin - Slot generation summary retrieved:', {
      workingDaysConfigured: workingDaysSummary.configuredDays,
      totalDatesWithSlots: datesWithSlots,
      totalSlotsGenerated: totalSlotsGenerated[0]?.total || 0
    });
    
    res.status(200).json({
      success: true,
      message: 'Slot generation summary retrieved successfully',
      data: {
        workingDays: workingDaysSummary,
        slotStatistics: {
          totalDatesWithSlots: datesWithSlots,
          totalSlotsGenerated: totalSlotsGenerated[0]?.total || 0,
          averageSlotsPerDay: datesWithSlots > 0 ? Math.round((totalSlotsGenerated[0]?.total || 0) / datesWithSlots) : 0
        },
        upcomingSlots: upcomingSlots.map(day => ({
          date: day.date.toISOString().split('T')[0],
          slotsCount: day.slots.length,
          availableSlots: day.availableSlotsCount
        })),
        automationConfig: {
          defaultSlotDuration: 60,
          defaultMaxBookings: 5,
          autoGenerateDaysAhead: 365,
          supportedDateRange: '2 years'
        }
      }
    });
  } catch (error) {
    console.error('âŒ Admin - Error getting slot generation summary:', error);
    res.status(500).json({
      success: false,
      message: 'Error getting slot generation summary',
      error: error.message
    });
  }
};

// Admin: Bulk generate slots for a date range
export const bulkGenerateSlots = async (req, res) => {
  try {
    const { startDate, endDate } = req.body;
    const createdBy = req.user.id;
    
    console.log('ğŸ‘‘ Admin - Bulk generating slots:', {
      startDate,
      endDate,
      createdBy
    });
    
    if (!startDate || !endDate) {
      return res.status(400).json({
        success: false,
        message: 'startDate and endDate are required'
      });
    }
    
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    if (start > end) {
      return res.status(400).json({
        success: false,
        message: 'startDate must be before endDate'
      });
    }
    
    // Check date range (max 90 days for bulk generation)
    const diffTime = Math.abs(end - start);
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays > 90) {
      return res.status(400).json({
        success: false,
        message: 'Date range cannot exceed 90 days for bulk generation'
      });
    }
    
    // Use the middleware logic
    req.query = { startDate, endDate };
    req.user = { id: createdBy };
    
    await bulkGenerateSlotsForRange(req, res, () => {
      const result = req.bulkGenerationResult;
      
      console.log('âœ… Admin - Bulk slot generation completed:', result.summary);
      
      res.status(200).json({
        success: true,
        message: 'Bulk slot generation completed successfully',
        data: result
      });
    });
  } catch (error) {
    console.error('âŒ Admin - Error in bulk slot generation:', error);
    res.status(500).json({
      success: false,
      message: 'Error generating slots in bulk',
      error: error.message
    });
  }
};

// Admin: Generate slots for next N days
export const generateSlotsForNextDays = async (req, res) => {
  try {
    const { days = 30 } = req.query;
    const createdBy = req.user.id;
    
    console.log('ğŸ‘‘ Admin - Generating slots for next days:', {
      days: parseInt(days),
      createdBy
    });
    
    const daysToGenerate = Math.min(parseInt(days), 90); // Max 90 days
    
    const today = new Date();
    const endDate = new Date();
    endDate.setDate(today.getDate() + daysToGenerate);
    
    const startDateStr = today.toISOString().split('T')[0];
    const endDateStr = endDate.toISOString().split('T')[0];
    
    // Use bulk generation logic
    req.query = { startDate: startDateStr, endDate: endDateStr };
    req.user = { id: createdBy };
    
    await bulkGenerateSlotsForRange(req, res, () => {
      const result = req.bulkGenerationResult;
      
      console.log('âœ… Admin - Next days slot generation completed:', result.summary);
      
      res.status(200).json({
        success: true,
        message: `Slots generated for next ${daysToGenerate} days successfully`,
        data: {
          ...result,
          generationPeriod: {
            startDate: startDateStr,
            endDate: endDateStr,
            daysGenerated: daysToGenerate
          }
        }
      });
    });
  } catch (error) {
    console.error('âŒ Admin - Error generating slots for next days:', error);
    res.status(500).json({
      success: false,
      message: 'Error generating slots for next days',
      error: error.message
    });
  }
};

// Admin: Auto-generate slots for a specific date
export const generateSlotsForDate = async (req, res) => {
  try {
    const { date } = req.params;
    const createdBy = req.user.id;
    
    console.log('ğŸ‘‘ Admin - Generating slots for specific date:', {
      date,
      createdBy
    });
    
    const targetDate = new Date(date);
    const dayOfWeek = targetDate.getDay();
    
    // Check if slots already exist
    const existingSlots = await DailySlots.findByDate(targetDate);
    if (existingSlots) {
      return res.status(409).json({
        success: false,
        message: 'Slots already exist for this date',
        data: {
          date: date,
          existingSlotsCount: existingSlots.slots.length,
          dailySlotsId: existingSlots._id
        }
      });
    }
    
    // Get working day configuration
    const workingDay = await WorkingDays.findOne({ dayOfWeek, isActive: true });
    
    if (!workingDay || !workingDay.isWorking) {
      return res.status(400).json({
        success: false,
        message: 'Cannot generate slots - not a working day',
        data: {
          date: date,
          dayOfWeek,
          dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
          isWorkingDay: false
        }
      });
    }
    
    // Generate slots (reuse the logic from middleware)
    const slots = generateSlotsFromWorkingDay(workingDay);
    
    const dailySlots = new DailySlots({
      date: targetDate,
      slots: slots,
      createdBy,
      notes: `Admin generated slots for ${workingDay.dayName}`
    });
    
    await dailySlots.save();
    
    console.log('âœ… Admin - Slots generated for date:', {
      date,
      slotsCount: slots.length,
      dailySlotsId: dailySlots._id
    });
    
    res.status(201).json({
      success: true,
      message: 'Slots generated successfully for the date',
      data: {
        date: dailySlots.date,
        dayOfWeek,
        dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
        workingHours: `${workingDay.startTime}-${workingDay.endTime}`,
        slots: dailySlots.slots,
        totalSlots: dailySlots.totalSlots,
        availableSlotsCount: dailySlots.availableSlotsCount,
        dailySlotsId: dailySlots._id
      }
    });
  } catch (error) {
    console.error('âŒ Admin - Error generating slots for date:', error);
    res.status(500).json({
      success: false,
      message: 'Error generating slots for date',
      error: error.message
    });
  }
};

// Helper function to generate slots from working day (reused from middleware)
function generateSlotsFromWorkingDay(workingDay) {
  const slots = [];
  const slotDuration = 60; // 60 minutes per slot
  const maxBookings = 5;   // 5 bookings per slot
  
  // Convert times to minutes for easier calculation
  const startMinutes = workingDay.startTime.split(':').reduce((acc, time) => (60 * acc) + +time);
  const endMinutes = workingDay.endTime.split(':').reduce((acc, time) => (60 * acc) + +time);
  
  let breakStartMinutes = null;
  let breakEndMinutes = null;
  
  if (workingDay.breakStart && workingDay.breakEnd) {
    breakStartMinutes = workingDay.breakStart.split(':').reduce((acc, time) => (60 * acc) + +time);
    breakEndMinutes = workingDay.breakEnd.split(':').reduce((acc, time) => (60 * acc) + +time);
  }
  
  // Generate slots
  let currentMinutes = startMinutes;
  
  while (currentMinutes + slotDuration <= endMinutes) {
    const slotEndMinutes = currentMinutes + slotDuration;
    
    // Skip break time
    if (breakStartMinutes && breakEndMinutes) {
      // If slot overlaps with break time, skip to after break
      if (currentMinutes < breakEndMinutes && slotEndMinutes > breakStartMinutes) {
        currentMinutes = breakEndMinutes;
        continue;
      }
    }
    
    // Convert minutes back to time format
    const startTime = Math.floor(currentMinutes / 60).toString().padStart(2, '0') + 
                     ':' + (currentMinutes % 60).toString().padStart(2, '0');
    const endTime = Math.floor(slotEndMinutes / 60).toString().padStart(2, '0') + 
                   ':' + (slotEndMinutes % 60).toString().padStart(2, '0');
    
    slots.push({
      startTime,
      endTime,
      maxBookings,
      currentBookings: 0,
      isAvailable: true,
      notes: `Generated slot for ${workingDay.dayName}`
    });
    
    currentMinutes += slotDuration;
  }
  
  return slots;
}

// Admin: Get slots generation status for a date range
export const getSlotsGenerationStatus = async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    const userId = req.user.id;
    
    console.log('ğŸ‘‘ Admin - Getting slots generation status:', {
      startDate,
      endDate,
      userId
    });
    
    if (!startDate || !endDate) {
      return res.status(400).json({
        success: false,
        message: 'startDate and endDate query parameters are required'
      });
    }
    
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    // Get existing slots in the date range
    const existingSlots = await DailySlots.find({
      date: { $gte: start, $lte: end },
      isActive: true
    }).sort({ date: 1 });
    
    // Get working days configuration
    const workingDays = await WorkingDays.find({ isActive: true });
    const workingDaysMap = {};
    workingDays.forEach(day => {
      workingDaysMap[day.dayOfWeek] = day;
    });
    
    // Generate status for each date in range
    const statusReport = [];
    const currentDate = new Date(start);
    
    while (currentDate <= end) {
      const dateStr = currentDate.toISOString().split('T')[0];
      const dayOfWeek = currentDate.getDay();
      const workingDay = workingDaysMap[dayOfWeek];
      
      const existingSlotsForDate = existingSlots.find(slots => 
        slots.date.toISOString().split('T')[0] === dateStr
      );
      
      statusReport.push({
        date: dateStr,
        dayOfWeek,
        dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
        isWorkingDay: workingDay ? workingDay.isWorking : false,
        workingHours: workingDay && workingDay.isWorking ? `${workingDay.startTime}-${workingDay.endTime}` : 'Closed',
        hasSlots: !!existingSlotsForDate,
        slotsCount: existingSlotsForDate ? existingSlotsForDate.slots.length : 0,
        availableSlots: existingSlotsForDate ? existingSlotsForDate.availableSlotsCount : 0,
        needsGeneration: workingDay && workingDay.isWorking && !existingSlotsForDate,
        dailySlotsId: existingSlotsForDate ? existingSlotsForDate._id : null
      });
      
      currentDate.setDate(currentDate.getDate() + 1);
    }
    
    const summary = {
      totalDates: statusReport.length,
      workingDays: statusReport.filter(item => item.isWorkingDay).length,
      datesWithSlots: statusReport.filter(item => item.hasSlots).length,
      datesNeedingGeneration: statusReport.filter(item => item.needsGeneration).length,
      totalSlotsGenerated: statusReport.reduce((sum, item) => sum + item.slotsCount, 0)
    };
    
    console.log('âœ… Admin - Slots generation status retrieved:', summary);
    
    res.status(200).json({
      success: true,
      message: 'Slots generation status retrieved successfully',
      data: {
        dateRange: { startDate, endDate },
        summary,
        statusReport
      }
    });
  } catch (error) {
    console.error('âŒ Admin - Error getting slots generation status:', error);
    res.status(500).json({
      success: false,
      message: 'Error getting slots generation status',
      error: error.message
    });
  }
};

